### 跨进程文件共享方案

方案1：进程之间共用一个外部存储目录</br>
方案2：进程A的私有目录通过`ContentProvider`暴露给其他进程

### 优缺点
#### 方案1：进程之间共用一个外部存储目录
###### 优点：
- 不需要任何逻辑，其他进程就能访问到共享目录，效率最高，无性能问题；
- 不占应用存储大小

###### 缺点：
- 受Android系统版本的分区存储影响，可能日后会随着Android存储系统权限的收紧而导致大改；
- 文件夹权限不受控，能被任何应用和用户随意更改，不可控；
- 应用卸载对应缓存还存在手机中

#### 方案2：进程A的私有目录通过ContentProvider暴露给其他进程
###### 优点：
- 资源存放在私有目录，其他应用和普通用户无权限不能访问
- 可以定制其他应用访问策略，按需共享资源和目录
- 可随应用卸载清除私有目录缓存
- 不受Android分区存储和权限收紧等系统版本迭代影响

###### 缺点：
- 相对于方案1，其他进程只能拿到资源的文件描述符，若资源类型多种多样，业务方需要有相应方法通过文件描述符或者输入流处理业务逻辑，接入有一定的学习成本；目前其他业务方都是通过方案1接入，切换需要成本
- 占用应用存储大小

### 方案2原理浅析（ContentProvider共享文件）
我们这里先抛出ContentProvider的文件共享底层原理是Binder + Ashmem，然后我们一步步看看Binder + Ashmem在其中是发挥怎么样的作用的。</br>

#### Binder
这里先贴出代码：</br>
服务端：
```java
public class ResProvider extends ContentProvider {
  ...

  @Override
  public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
      if (共享策略) return;
      return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
  }
}

```
业务端：
```java
ParcelFileDescriptor mDescriptor = getContentResolver().openFileDescriptor(Uri.parse(uri), "r")
```

可以看到进程间传递的是`ParcelFileDescriptor`，我们知道，在Linux系统中，文件描述符其实就是一个整数，它是用来索引进程保存在内核空间的打开文件数据结构的，而且，这个文件描述符只是在进程内有效，也就是说，在不同的进程中，相同的文件描述符的值，代表的可能是不同的打开文件，既然是这样，把Server进程中的[文件描述符](https://juejin.cn/post/6906444643089514510)传给Client进程，似乎就没有用了，但是不用担心，在传输过程中，Binder驱动程序会帮我们处理好一切，保证Client进程拿到的文件描述符是在本进程中有效的，并且它指向就是Server进程创建的匿名共享内存文件。

#### Ashmem
##### MemoryFile
MemoryFile是Android为匿名共享内存而封装的一个对象，这里通过使用MemoryFile来分析，Android中如何利用共享内存来实现大数据传递，同时MemoryFile也是进程间大数据传递的一个手段，开发的时候可以使用：
```java
 public class MemoryFile  
 {  
     ......  

     /**
     * Allocates a new ashmem region. The region is initially not purgable.
     * 分配一块新的Ashmem区域
     */  
     public MemoryFile(String name, int length) throws IOException {  
         mLength = length;  
         // 开辟一块匿名内存
         mFD = native_open(name, length);
         // 返回虚拟空间的起始地址
         mAddress = native_mmap(mFD, length, PROT_READ | PROT_WRITE);  
         mOwnsRegion = true;  
     }  

     /**
     * Creates a reference to an existing memory file. Changes to the original file
     * will be available through this reference.
     * Calls to {@link #allowPurging(boolean)} on the returned MemoryFile will fail.
     * @hide
     */  
     public MemoryFile(FileDescriptor fd, int length, String mode) throws IOException {  
         if (fd == null) {  
             throw new NullPointerException("File descriptor is null.");  
         }  
         if (!isMemoryFile(fd)) {  
             throw new IllegalArgumentException("Not a memory file.");  
         }  
         mLength = length;  
         mFD = fd;  
         mAddress = native_mmap(mFD, length, modeToProt(mode));  
         mOwnsRegion = false;  
     }  

     ......  
 }  
```
从注释中，我们可以看出这两个构造函数的使用方法，这里就不再详述了。两个构造函数的主要区别是第一个参数，第一种构造方法是以指定的字符串调用JNI方法native_open来创建一个匿名共享内存文件，从而得到一个文件描述符，接着就以这个文件描述符为参数调用JNI方法natvie_mmap把这个匿名共享内存文件映射在进程空间中，然后就可以通过这个映射后得到的地址空间来直接访问内存数据了；第二种构造方法是以指定的文件描述符来直接调用JNI方法natvie_mmap把这个匿名共享内存文件映射在进程空间中，然后进行访问，而这个文件描述符就必须要是一个匿名共享内存文件的文件描述符，这是通过一个内部函数isMemoryFile来验证的，而这个内部函数isMemoryFile也是通过JNI方法调用来进一步验证的。前面所提到的这些JNI方法调用，最终都是通过系统运行时库层进入到内核空间的Ashmem驱动程序中去，不过这里我们不关心这些JNI方法。</br>

![共享文件原理](https://raw.githubusercontent.com/huanzhiyazi/articles/master/%E6%8A%80%E6%9C%AF/android/Android%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88ashmem%EF%BC%89%E5%8E%9F%E7%90%86/images/ashmem_transfer_fd.png)

大致思路和流程是：
- 服务端通过 tmpfs 创建一块共享区域，得到这块区域的 fd（文件描述符）
- 服务端 在 fd 上 mmap 一片内存区域到本进程用于共享数据
- 服务端 通过Binder把 fd 倒腾给 客户端
- 客户端 在接到的 fd 上同样 mmap 相同的区域到本进程
- 然后 服务端、客户端 在 mmap 到本进程中的内存中读、写，对方都能看到了

其实核心点就是创建一块共享区域，然后2个进程同时把这片区域 mmap 到本进程，然后读写就像本进程的内存一样。这里要解释下第3步，为什么要倒腾 fd，因为在 linux 中 fd 只是对本进程是唯一的，在 进程A 中打开一个文件得到一个 fd，但是把这个打开的 fd 直接放到 进程B 中，进程B 是无法直接使用的。但是文件是唯一的，就是说一个文件（file）可以被打开多次，每打开一次就有一个 fd（文件描述符），所以对于同一个文件来说，需要某种转化，把 进程A 中的 fd 转化成 进程B 中的 fd。这样 进程B 才能通过 fd mmap 同样的共享内存文件。


关于tmpfs和过程中内存分配等更多Ashmem相关更细的内容，可以看下一篇文章：[Ashmem详细分析](https://www.kancloud.cn/alex_wsc/androids/477704)</br>

### 推荐阅读
[1] [Android Ashmem驱动系统](https://www.kancloud.cn/alex_wsc/androids/477716)</br>
[2] [FD在Binder中的转换过程解析](https://www.kancloud.cn/alex_wsc/androids/477718)</br>
