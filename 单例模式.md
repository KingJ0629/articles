### 意图
> 单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。

![意图](https://refactoringguru.cn/images/patterns/content/singleton/singleton.png?id=108a0b9b5ea5c4426e0a)


### 实现
#### 饿汉模式
```java
// 饿汉模式
public final class Singleton {
    private static Singleton instance = new Singleton(); // 自行创建实例
    private Singleton() {} // 构造函数
    public static Singleton getInstance() { // 通过该函数向整个系统提供实例
        return instance;
    }
}
```

从代码中我们看到，类的构造函数定义为`private`的，保证其他类不能实例化此类，然后提供了一个静态实例并返回给调用者。饿汉模式是最简单的一种实现方式，饿汉模式在类加载的时候就对实例进行创建，实例在整个程序周期都存在。

- 它的好处是只在类加载的时候创建一次实例，不会存在多个线程创建多个实例的情况，避免了多线程同步的问题。
- 它的缺点也很明显，即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了。
- 这种实现方式适合单例占用内存比较小，在初始化时就会被用到的情况。但是，如果单例占用的内存比较大，或单例只是在某个特定场景下才会用到，使用饿汉模式就不合适了，这时候就需要用到懒汉模式进行延迟加载。


#### 懒汉模式
```java
 public final class Singleton {
     private static Singleton instance = null; // 不实例化
     private Singleton() {} // 构造函数
     public static Singleton getInstance() { // 通过该函数向整个系统提供实例
         if(null == instance) { // 当 instance 为 null 时，则实例化对象，否则直接返回对象
             instance = new Singleton(); // 实例化对象
         }
         return instance;// 返回已存在的对象
     }
 }
 ```
- 好处：懒汉模式中单例是在需要的时候才去创建的，如果单例已经创建，再次调用获取接口将不会重新创建新的对象，而是直接返回之前创建的对象。
- 适用于：如果某个单例使用的次数少，并且创建单例消耗的资源较多，那么就需要实现单例的按需创建，这个时候使用懒汉模式就是一个不错的选择。
- 缺点：但是这里的懒汉模式并没有考虑线程安全问题，在多个线程可能会并发调用它的`getInstance()`方法，导致创建多个实例，因此需要加锁解决线程同步问题，实现如下:

```java
// 懒汉模式 + synchronized 同步锁
public final class Singleton {
   private static Singleton instance = null; // 不实例化
   private Singleton() {} // 构造函数
   public static synchronized Singleton getInstance() { // 加同步锁，通过该函数向整个系统提供实例
       if(null == instance) { // 当 instance 为 null 时，则实例化对象，否则直接返回对象
           instance = new Singleton(); // 实例化对象
       }
       return instance;// 返回已存在的对象
   }
}
```
以上代码在单线程下运行是没有问题的，但要运行在多线程下，就会出现实例化多个类对象的情况。这是怎么回事呢？ <br />
当线程 A 进入到 `if` 判断条件后，开始实例化对象，此时 `instance` 依然为 `null`；又有线程 B 进入到 `if` 判断条件中，之后也会通过条件判断，进入到方法里面创建一个实例对象。 <br />
所以我们需要对该方法进行加锁，保证多线程情况下仅创建一个实例。这里我们使用 `Synchronized` 同步锁来修饰 `getInstance` 方法： <br />
但同步锁会增加锁竞争，带来系统性能开销，从而导致系统性能下降，因此这种方式也会降低单例模式的性能。

还有，每次请求获取类对象时，都会通过 `getInstance()` 方法获取，除了第一次为 `null`，其它每次请求基本都是不为 `null` 的。基于以上几点，我们可以考虑将同步锁放在 `if` 条件里面，这样就可以减少同步锁资源竞争。

```java
// 懒汉模式 + synchronized 同步锁
public final class Singleton {
   private static Singleton instance = null; // 不实例化
   private Singleton() {} // 构造函数
   public static Singleton getInstance() { // 加同步锁，通过该函数向整个系统提供实例
       if(null == instance) { // 当 instance 为 null 时，则实例化对象，否则直接返回对象
         synchronized (Singleton.class) {
             instance = new Singleton(); // 实例化对象
         }
       }
       return instance; // 返回已存在的对象
   }
}
```
你是不是觉得这样就可以了呢？答案是依然会创建多个实例。这是因为当多个线程进入到 `if` 判断条件里，虽然有同步锁，但是进入到判断条件里面的线程依然会依次获取到锁创建对象，然后再释放同步锁。所以我们还需要在同步锁里面再加一个判断条件

#### 双重校验锁【推荐】
加锁的懒汉模式看起来即解决了线程并发问题，又实现了延迟加载，然而它存在着性能问题，依然不够完美。<br />
`synchronized`修饰的同步方法比一般方法要慢很多，如果多次调用`getInstance()`，累积的性能损耗就比较大了。<br/>
因此就有了双重校验锁，先看下它的实现代码。
```java
// 懒汉模式 + synchronized 同步锁 + double-check
public final class Singleton {
   private static Singleton instance = null;// 不实例化
   private Singleton() {}// 构造函数
   public static Singleton getInstance() {// 加同步锁，通过该函数向整个系统提供实例
       if(null == instance) {// 第一次判断，当 instance 为 null 时，则实例化对象，否则直接返回对象
         synchronized (Singleton.class) {// 同步锁
            if(null == instance) {// 第二次判断
               instance = new Singleton();// 实例化对象
            }
         }
       }
       return instance;// 返回已存在的对象
   }
}
```
可以看到上面在同步代码块内多了一层`instance`为空的判断。由于单例对象只需要创建一次，如果后面再次调用`getInstance()`只需要直接返回单例对象。

因此，大部分情况下，调用`getInstance()`都不会执行到同步代码块，从而提高了程序性能。
不过还需要考虑一种情况，假如两个线程A、B，A执行了`if (instance == null)`语句，它会认为单例对象没有创建，此时线程切到B也执行了同样的语句，B也认为单例对象没有创建，然后两个线程依次执行同步代码块，并分别创建了一个单例对象。为了解决这个问题，还需要在同步代码块中增加`if (instance == null)`语句，也就是上面看到的代码中的校验2。

双检锁隐患：
> 我们看到双重校验锁即实现了延迟加载，又解决了线程并发问题，同时还解决了执行效率问题，是否真的就万无一失了呢？

这里要提到Java中的指令重排优化和 `Happens-Before` 规则。所谓指令重排优化是指在不改变原语义的情况下，通过调整指令的执行顺序让程序运行的更快。<br />
JVM中并没有规定编译器优化相关的内容，也就是说JVM可以自由的进行指令重排序的优化。<br />
这个问题的关键就在于由于指令重排优化的存在，导致初始化`Singleton`和将对象地址赋给`instance`字段的顺序是不确定的。<br />
在某个线程创建单例对象时，在构造方法被调用之前，就为该对象分配了内存空间并将对象的字段设置为默认值。<br />
此时就可以将分配的内存地址赋值给`instance`字段了，然而该对象可能还没有初始化。若紧接着另外一个线程来调用`getInstance`，取到的就是状态不正确的对象，程序就会出错。

> Happens-Before规则 <br />
通过字面意思，你可能会误以为是前一个操作发生在后一个操作之前。然而真正的意思是，前一个操作的结果可以被后续的操作获取。这条规则规范了编译器对程序的重排序优化。

>JDK5的修正：以上就是双重校验锁会失效的原因，不过还好在JDK1.5及之后版本增加了volatile关键字。 <br />
`volatile`的一个语义是禁止指令重排序优化，也就保证了`instance`变量被赋值的时候对象已经是初始化过的，从而避免了上面说到的问题。 <br />
Java中的`volatile`变量是什么？ <br />
理解`volatile`关键字的作用的前提是要理解Java内存模型，`volatile`关键字的作用主要有两个：
- 多线程主要围绕可见性和原子性两个特性而展开，使用`volatile`关键字修饰的变量，保证了其在多线程之间的可见性，
即每次读取到volatile变量，一定是最新的数据
- 代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–>字节码–>根据字节码执行对应的C/C++代码–>C/C++代码被编译成汇编语言–>和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。
- 使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率
- 从实践角度而言，`volatile`的一个重要作用就是和`CAS`结合，保证了原子性，详细的可以参见`java.util.concurrent.atomic`包下的类，比如`AtomicInteger`。`CAS（Compare and swap）`比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。

代码如下：
```Java
// 懒汉模式 + synchronized 同步锁 + double-check
public final class Singleton {
   private volatile static Singleton instance = null; // 不实例化
   private Singleton() {} // 构造函数
   public static Singleton getInstance() { // 加同步锁，通过该函数向整个系统提供实例
       if(null == instance) { // 第一次判断，当 instance 为 null 时，则实例化对象，否则直接返回对象
         synchronized (Singleton.class) { // 同步锁
            if(null == instance) { // 第二次判断
               instance = new Singleton(); // 实例化对象
            }
         }
       }
       return instance;// 返回已存在的对象
   }
}
```
#### 静态内部类【推荐】
除了上面的三种方式，还有另外一种实现单例的方式，通过静态内部类来实现。
首先看一下它的实现代码：
```Java
// 懒汉模式 内部类实现
public final class Singleton {
	private Singleton() {} // 构造函数

	// 内部类实现
	public static class InnerSingleton {
		private static Singleton instance = new Singleton(); // 自行创建实例
	}

	public static Singleton getInstance() {
		return InnerSingleton.instance; // 返回内部类中的静态变量
	}
}
```


这种方式同样利用了类加载机制来保证只创建一个`instance`实例。它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。<br />
不一样的是，它是在内部类里面去创建对象实例。<br />
这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。
#### 枚举
> 枚举模式最安全，反射和序列化都是单例。<br />
《Effective Java》作者也是强烈推荐枚举方式实现单例。

```Java
public class Resource {
   private Resource() {}
   /**
    * 枚举类型是线程安全的，并且只会装载一次
    */
   private enum Singleton {
       INSTANCE;
       private final Resource instance;
       Singleton() {
           instance = new Resource();
       }

       private Resource getInstance() {
           return instance;
       }
   }

   public static Resource getInstance() {
       return Singleton.INSTANCE.getInstance();
   }
}
```
上面的类`Resource`是我们要应用单例模式的资源，具体可以表现为网络连接，数据库连接，线程池等等。<br />
获取资源的方式很简单，只要 `Singleton.INSTANCE.getInstance()`即可获得所要实例。

下面我们来看看单例是如何被保证的：

- 首先，在枚举中我们明确了构造方法限制为私有，在我们访问枚举实例时会执行构造方法。
- 同时每个枚举实例都是`static final`类型的，也就表明只能被实例化一次。在调用构造方法时，我们的单例被实例化。
- 也就是说，因为enum中的实例被保证只会被实例化一次，所以我们的`INSTANCE`也被保证实例化一次。

可以看到，枚举实现单例还是比较简单的，除此之外我们再来看一下Enum这个类的声明：
>public abstract class Enum<E extends Enum<E>>implements Comparable<E>, Serializable

可以看到，枚举也提供了序列化机制。某些情况，比如我们要通过网络传输一个数据库连接的句柄，会提供很多帮助。<br />
最后借用 《Effective Java》一书中的话，
>单元素的枚举类型已经成为实现`Singleton`的最佳方法。

上面提到的四种实现单例的方式都有共同的缺点：
- 需要额外的工作来实现序列化，否则每次反序列化一个序列化的对象时都会创建一个新的实例。
- 可以使用反射强行调用私有构造器（如果要避免这种情况，可以修改构造器，让它在创建第二个实例的时候抛异常）。

而枚举类很好的解决了这两个问题，使用枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。


### 如何选择
- 如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用；

- 如果我们是写一些工具类，则优先考虑使用懒汉模式，因为很多项目可能会引用到 `jar` 包，但未必会使用到这个工具类，懒汉模式实现的单例可以避免提前被加载到内存中，占用系统资源。


### 参考
[Java单例模式的不同写法](https://blog.csdn.net/fly910905/article/details/79286680)
